%% Client Architecture: State Update and Reconciliation Flow
%% Sequence diagram showing server state update and reconciliation

sequenceDiagram
    participant Server as Game Server
    participant WSClient as WebSocketClient
    participant NetworkedMode as Networked Mode
    participant MessageHandler as MessageHandler
    participant StateComparison as StateComparison
    participant Canvas as Canvas
    participant Renderer as Renderer
    
    Note over Server,Renderer: State Update and Reconciliation Sequence
    
    loop Every 250ms (server broadcast)
        Server->>WSClient: STATE_UPDATE message (JSON)
        WSClient->>WSClient: Emit 'message' event
        WSClient->>NetworkedMode: 'message' event (data)
        
        NetworkedMode->>MessageHandler: parseMessage(data)
        MessageHandler-->>NetworkedMode: Parsed message object
        
        NetworkedMode->>NetworkedMode: previousState = currentState
        NetworkedMode->>NetworkedMode: currentState = message.payload
        
        NetworkedMode->>NetworkedMode: For each remote player: push { t, x, y, playerName, vx?, vy? } to buffer (cap size)
        NetworkedMode->>NetworkedMode: For players no longer in payload: clear last-drawn cell, remove buffer and interpolated/last-drawn entries
        
        NetworkedMode->>NetworkedMode: reconcilePosition()
        NetworkedMode->>NetworkedMode: Get server position for local player
        NetworkedMode->>NetworkedMode: Compare with predicted position
        
        alt Positions match
            Note over NetworkedMode: Prediction correct, no correction needed
        else Positions differ
            NetworkedMode->>NetworkedMode: Update prediction to match server
            NetworkedMode->>NetworkedMode: localPlayerPredictedPosition = server position
            Note over NetworkedMode: Correction applied
        end
        
        NetworkedMode->>StateComparison: compareStates(previousState, currentState)
        StateComparison->>StateComparison: Detect moved players
        StateComparison->>StateComparison: Detect joined players
        StateComparison->>StateComparison: Detect left players
        StateComparison->>StateComparison: Detect score changes
        StateComparison-->>NetworkedMode: Changes object
        
        NetworkedMode->>NetworkedMode: Filter local player from changes
        
        alt Too many changes (>10) or previousState is null
            NetworkedMode->>Canvas: renderBoard(board, players, layout) or full composition
            Canvas-->>NetworkedMode: Grid ready
        else Incremental render
            NetworkedMode->>Canvas: renderIncremental(changes, board, players, entities, ...)
            Canvas->>Canvas: Update only changed cells in grid (status bar part of grid)
            Canvas-->>NetworkedMode: Grid ready
        end
        
        NetworkedMode->>Renderer: render(canvas)
        Renderer-->>NetworkedMode: Render complete
    end
    
    Note over NetworkedMode,Renderer: "Interpolation tick (every 50ms): renderTime = now - INTERPOLATION_DELAY_MS then for each remote entity buffer compute interpolated or extrapolated position then for each entity whose rounded position changed restoreCellContent(old) updateCell(new) update lastDrawnInterpolatedPositions then renderer.render(canvas)"
